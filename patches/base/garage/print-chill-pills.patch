diff --git a/src/db/bin/convert.rs b/src/db/bin/convert.rs
index bbde204..7bed4b0 100644
--- a/src/db/bin/convert.rs
+++ b/src/db/bin/convert.rs
@@ -4,6 +4,28 @@ use garage_db::*;
 
 use clap::Parser;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 /// K2V command line interface
 #[derive(Parser, Debug)]
 #[clap(author, version, about, long_about = None)]
diff --git a/src/db/lib.rs b/src/db/lib.rs
index 11cae4e..ffef3fa 100644
--- a/src/db/lib.rs
+++ b/src/db/lib.rs
@@ -25,6 +25,18 @@ use std::sync::Arc;
 
 use err_derive::Error;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 #[derive(Clone)]
 pub struct Db(pub(crate) Arc<dyn IDb>);
 
diff --git a/src/garage/cli/cmd.rs b/src/garage/cli/cmd.rs
index 0d73588..6bf4ecc 100644
--- a/src/garage/cli/cmd.rs
+++ b/src/garage/cli/cmd.rs
@@ -13,6 +13,28 @@ use garage_model::helper::error::Error as HelperError;
 use crate::admin::*;
 use crate::cli::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub async fn cli_command_dispatch(
 	cmd: Command,
 	system_rpc_endpoint: &Endpoint<SystemRpc, ()>,
diff --git a/src/garage/cli/init.rs b/src/garage/cli/init.rs
index 20813f1..f4baea2 100644
--- a/src/garage/cli/init.rs
+++ b/src/garage/cli/init.rs
@@ -2,6 +2,18 @@ use std::path::PathBuf;
 
 use garage_util::error::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub const READ_KEY_ERROR: &str = "Unable to read node key. It will be generated by your garage node the first time is it launched. Ensure that your garage node is currently running. (The node key is supposed to be stored in your metadata directory.)";
 
 pub fn node_id_command(config_file: PathBuf, quiet: bool) -> Result<(), Error> {
diff --git a/src/garage/cli/layout.rs b/src/garage/cli/layout.rs
index 3884bb9..ef55a66 100644
--- a/src/garage/cli/layout.rs
+++ b/src/garage/cli/layout.rs
@@ -8,6 +8,28 @@ use garage_rpc::*;
 
 use crate::cli::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub async fn cli_layout_command_dispatch(
 	cmd: LayoutOperation,
 	system_rpc_endpoint: &Endpoint<SystemRpc, ()>,
diff --git a/src/garage/cli/util.rs b/src/garage/cli/util.rs
index 2c6be2f..db6f25d 100644
--- a/src/garage/cli/util.rs
+++ b/src/garage/cli/util.rs
@@ -17,6 +17,28 @@ use garage_model::s3::version_table::Version;
 
 use crate::cli::structs::WorkerListOpt;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub fn print_bucket_list(bl: Vec<Bucket>) {
 	println!("List of buckets:");
 
diff --git a/src/k2v-client/bin/k2v-cli.rs b/src/k2v-client/bin/k2v-cli.rs
index cdd63cc..dfa4df4 100644
--- a/src/k2v-client/bin/k2v-cli.rs
+++ b/src/k2v-client/bin/k2v-cli.rs
@@ -11,6 +11,28 @@ use rusoto_core::Region;
 
 use clap::{Parser, Subcommand};
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 /// K2V command line interface
 #[derive(Parser, Debug)]
 #[clap(author, version, about, long_about = None)]
diff --git a/src/rpc/layout.rs b/src/rpc/layout.rs
index 1030e3a..47eca49 100644
--- a/src/rpc/layout.rs
+++ b/src/rpc/layout.rs
@@ -10,6 +10,28 @@ use garage_util::error::*;
 
 use crate::ring::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 /// The layout of the cluster, i.e. the list of roles
 /// which are assigned to each cluster node
 #[derive(Clone, Debug, Serialize, Deserialize)]
diff --git a/src/util/formater.rs b/src/util/formater.rs
index 2ea53eb..cc7d8a4 100644
--- a/src/util/formater.rs
+++ b/src/util/formater.rs
@@ -1,3 +1,15 @@
+use std::io::Write;
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub fn format_table_to_string(data: Vec<String>) -> String {
 	let data = data
 		.iter()
