diff --git a/src/db/lib.rs b/src/db/lib.rs
index 11cae4e3..ffef3fac 100644
--- a/src/db/lib.rs
+++ b/src/db/lib.rs
@@ -25,6 +25,18 @@ use std::sync::Arc;
 
 use err_derive::Error;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 #[derive(Clone)]
 pub struct Db(pub(crate) Arc<dyn IDb>);
 
diff --git a/src/format-table/lib.rs b/src/format-table/lib.rs
index 55252ba9..4d8caf1d 100644
--- a/src/format-table/lib.rs
+++ b/src/format-table/lib.rs
@@ -13,6 +13,18 @@
 //! A table to be formatted is a `Vec<String>`, containing one string per line.
 //! Table columns in each line are separated by a `\t` character.
 
+use std::io::Write;
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 /// Format a table and return the result as a string.
 pub fn format_table_to_string(data: Vec<String>) -> String {
 	let data = data
diff --git a/src/garage/cli/cmd.rs b/src/garage/cli/cmd.rs
index cb7a898c..97093e69 100644
--- a/src/garage/cli/cmd.rs
+++ b/src/garage/cli/cmd.rs
@@ -13,6 +13,28 @@ use garage_model::helper::error::Error as HelperError;
 use crate::admin::*;
 use crate::cli::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub async fn cli_command_dispatch(
 	cmd: Command,
 	system_rpc_endpoint: &Endpoint<SystemRpc, ()>,
diff --git a/src/garage/cli/init.rs b/src/garage/cli/init.rs
index 20813f1c..f4baea29 100644
--- a/src/garage/cli/init.rs
+++ b/src/garage/cli/init.rs
@@ -2,6 +2,18 @@ use std::path::PathBuf;
 
 use garage_util::error::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub const READ_KEY_ERROR: &str = "Unable to read node key. It will be generated by your garage node the first time is it launched. Ensure that your garage node is currently running. (The node key is supposed to be stored in your metadata directory.)";
 
 pub fn node_id_command(config_file: PathBuf, quiet: bool) -> Result<(), Error> {
diff --git a/src/garage/cli/layout.rs b/src/garage/cli/layout.rs
index dc5315a1..193fd97c 100644
--- a/src/garage/cli/layout.rs
+++ b/src/garage/cli/layout.rs
@@ -8,6 +8,28 @@ use garage_rpc::*;
 
 use crate::cli::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub async fn cli_layout_command_dispatch(
 	cmd: LayoutOperation,
 	system_rpc_endpoint: &Endpoint<SystemRpc, ()>,
diff --git a/src/garage/cli/util.rs b/src/garage/cli/util.rs
index 1140cf22..e4c4d188 100644
--- a/src/garage/cli/util.rs
+++ b/src/garage/cli/util.rs
@@ -17,6 +17,28 @@ use garage_model::s3::version_table::Version;
 
 use crate::cli::structs::WorkerListOpt;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 pub fn print_bucket_list(bl: Vec<Bucket>) {
 	println!("List of buckets:");
 
diff --git a/src/k2v-client/bin/k2v-cli.rs b/src/k2v-client/bin/k2v-cli.rs
index b9461c89..b9cc1485 100644
--- a/src/k2v-client/bin/k2v-cli.rs
+++ b/src/k2v-client/bin/k2v-cli.rs
@@ -10,6 +10,28 @@ use format_table::format_table;
 
 use clap::{Parser, Subcommand};
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 /// K2V command line interface
 #[derive(Parser, Debug)]
 #[clap(author, version, about, long_about = None)]
diff --git a/src/rpc/layout.rs b/src/rpc/layout.rs
index 1030e3a6..47eca49d 100644
--- a/src/rpc/layout.rs
+++ b/src/rpc/layout.rs
@@ -10,6 +10,28 @@ use garage_util::error::*;
 
 use crate::ring::*;
 
+use std::io::Write;
+
+macro_rules! println {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    writeln!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    writeln!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
+macro_rules! print {
+  () => (print!("\n"));
+  ($fmt:expr) => ({
+    write!(std::io::stdout(), $fmt).unwrap_or(())
+  });
+  ($fmt:expr, $($arg:tt)*) => ({
+    write!(std::io::stdout(), $fmt, $($arg)*).unwrap_or(())
+  })
+}
+
 /// The layout of the cluster, i.e. the list of roles
 /// which are assigned to each cluster node
 #[derive(Clone, Debug, Serialize, Deserialize)]
